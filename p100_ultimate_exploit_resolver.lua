-- P100 Ultimate Exploit Resolver for GameSense API
-- This script handles various anti-aim exploits, desyncs, and more with advanced optimizations.

local resolver = {}
local bit = require("bit") -- Import bit library

-- Database for storing per-player resolver settings
local log_timestamps = {} -- Store last log times for each unique message
local last_baim_log = {}
local last_fake_duck_log = {}
local last_yaw_log_time = {} -- Cooldown storage
local last_log_time = {} -- Cooldown storage
local resolver_data = {}

local ui_elements = {
    enable_resolver = ui.new_checkbox("LUA", "B", "Enable Resolver"),
    enable_jitter_resolver = ui.new_checkbox("LUA", "B", "Enable Jitter Resolver"),
    enable_yaw_resolver = ui.new_checkbox("LUA", "B", "Enable Yaw Resolver"),
    enable_bruteforce_resolver = ui.new_checkbox("LUA", "B", "Enable Bruteforce Resolver"),
    enable_fake_lag_resolver = ui.new_checkbox("LUA", "B", "Enable Fake Lag Resolver"),
    enable_freestanding_resolver = ui.new_checkbox("LUA", "B", "Enable Freestanding Resolver"),
    enable_fix_fake_duck = ui.new_checkbox("LUA", "B", "Enable Fake Duck Resolver"),
    enable_backtrack_resolver = ui.new_checkbox("LUA", "B", "Enable Backtrack Resolver"),
    enable_adaptive_flip = ui.new_checkbox("LUA", "B", "Enable Adaptive Flip"),
    enable_exploit_detection = ui.new_checkbox("LUA", "B", "Enable Exploit Detection"),
    enable_defensive_aa_resolver = ui.new_checkbox("LUA", "B", "Enable Defensive AA Resolver"),
    enable_edge_yaw_counter = ui.new_checkbox("LUA", "B", "Enable Edge Yaw Counter"),
    enable_anti_miss_correction = ui.new_checkbox("LUA", "B", "Enable Anti-Miss Correction"),
    enable_lag_compensation_resolver = ui.new_checkbox("LUA", "B", "Enable Lag Compensation Resolver"),
    enable_hitbox_adjustment = ui.new_checkbox("LUA", "B", "Enable Hitbox Adjustment"),
    enable_yaw_bruteforce = ui.new_checkbox("LUA", "B", "Enable Yaw Bruteforce"),
    enable_deep_fake_angle_recognition = ui.new_checkbox("LUA", "B", "Enable Deep Fake Angle Recognition")
}

-- Function to initialize resolver data for a player
local function initialize_resolver_data(ent)
    local player_name = entity.get_player_name(ent)
    if not resolver_data[player_name] then
        resolver_data[player_name] = {
            aa_patterns = {},
            last_real_angle = nil,
            last_fake_angle = nil,
            missed_shots = 0,
            last_tick = 0,
            last_update_time = 0,
            angle_history = {},
            yaw_history = {},
            backtrack_positions = {},
            last_z = nil,
        }
    end
end



local function throttled_log(message, delay)
    delay = delay or 3 -- Default throttle delay (3 seconds)  
    local current_time = globals.realtime()

    -- If this message hasn't been logged before, initialize its time
    if not log_timestamps[message] then
        log_timestamps[message] = 0
    end

    -- **Only log if enough time has passed**
    if (current_time - log_timestamps[message]) >= delay then
        client.log(message) -- Log message
        log_timestamps[message] = current_time -- Update last log time
    end
end


-- Function to update resolver data based on missed shots
local function update_resolver_data(ent, missed)
    local player_name = entity.get_player_name(ent)
    resolver_data[player_name].missed_shots = resolver_data[player_name].missed_shots + (missed and 1 or 0)
end

-- Function to get desync delta
local function get_desync_delta(ent)
    local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
    local lby = entity.get_prop(ent, "m_flLowerBodyYawTarget") or real_angle -- Fallback if nil

    local desync_delta = math.abs(real_angle - lby) -- More accurate desync detection
    return desync_delta
end

-- Advanced Resolver with AI Intelligence
local function advanced_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
    local sim_time = entity.get_prop(ent, "m_flSimulationTime") or 0  

    -- Check if we have previous data
    if resolver_data[player_name].last_real_angle then
        local angle_diff = math.abs(real_angle - resolver_data[player_name].last_real_angle)

        -- If angle is shifting consistently, predict future movements
        if angle_diff > 15 then
            real_angle = resolver_data[player_name].last_real_angle + angle_diff
        else
            real_angle = sim_time * 100  -- Fallback (more reliable than PoseParameter)
        end
    end

    -- Store for next tick
    resolver_data[player_name].last_real_angle = real_angle

    -- Apply resolved angle
    entity.set_prop(ent, "m_angEyeAngles", real_angle)
end




local function fake_lag_exploit_punisher(ent)
    local player_name = entity.get_player_name(ent)
    local choked_ticks = globals.chokedcommands()

    if choked_ticks > 6 then
        throttled_log("âš ï¸ Fake Lag Detected: " .. player_name)

        -- Increase backtrack window dynamically
        if not resolver_data[player_name].backtrack_positions then
            resolver_data[player_name].backtrack_positions = {}
        end

        local pos_x, pos_y, pos_z = entity.get_origin(ent)
        table.insert(resolver_data[player_name].backtrack_positions, {x = pos_x, y = pos_y, z = pos_z, tick = globals.tickcount()})

        -- Keep only last 6 backtrack positions
        if #resolver_data[player_name].backtrack_positions > 6 then
            table.remove(resolver_data[player_name].backtrack_positions, 1)
        end

        throttled_log("ðŸ“Œ Increased backtrack window for " .. player_name)
    end
end


local function deep_fake_angle_recognition(ent)
    local player_name = entity.get_player_name(ent)
    local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
    local fake_angle = entity.get_prop(ent, "m_flPoseParameter") or 0

    -- Initialize resolver data if not exists
    if not resolver_data[player_name] then
        resolver_data[player_name] = {}
    end
    
    if not resolver_data[player_name].angle_history then
        resolver_data[player_name].angle_history = {}
    end

    -- Track the last 10 angles as numbers directly, not tables
    table.insert(resolver_data[player_name].angle_history, real_angle)

    if #resolver_data[player_name].angle_history > 10 then
        table.remove(resolver_data[player_name].angle_history, 1)
    end

    -- Check for consistent flipping patterns
    local flips = 0
    for i = 2, #resolver_data[player_name].angle_history do
        local prev_angle = resolver_data[player_name].angle_history[i - 1]
        local curr_angle = resolver_data[player_name].angle_history[i]

        -- Compare angles directly as numbers
        if prev_angle and curr_angle then
            if math.abs(curr_angle - prev_angle) > 25 then
                flips = flips + 1
            end
        end
    end

    if flips > 5 then
        throttled_log("âš ï¸ Fake Angle Detected on " .. player_name)
        entity.set_prop(ent, "m_angEyeAngles", real_angle)  -- Force real angle
    end
end


-- Function to resolve anti-aim exploiters
local function resolve_aa_exploit(ent)
    local player_name = entity.get_player_name(ent)
    local aa_patterns = resolver_data[player_name].aa_patterns

    -- Use AI-based learning to predict angles
    local real_angle = entity.get_prop(ent, "m_angEyeAngles")
    local fake_angle = entity.get_prop(ent, "m_flPoseParameter")

    -- Store and track patterns
    table.insert(aa_patterns, {real = real_angle, fake = fake_angle})

    -- Apply resolved angles
    advanced_resolver(ent)
end

-- Function to handle desync
local function resolve_desync(ent)
    local player_name = entity.get_player_name(ent)
    local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
    local fake_angle = entity.get_prop(ent, "m_flPoseParameter") or 0

    if not resolver_data[player_name] then
        resolver_data[player_name] = { last_real_angle = real_angle, last_fake_angle = fake_angle }
    end

    -- Calculate desync delta
    local desync_delta = math.abs(real_angle - fake_angle)

    -- If desync is high, force angle correction
    if desync_delta > 20 then
        local fixed_real = real_angle - (desync_delta / 2)
        entity.set_prop(ent, "m_angEyeAngles", fixed_real)
        client.log("ðŸ› ï¸ Fixed Desync on " .. player_name)
    end
end


-- Function to prevent being brute-resolved
local function prevent_bruteforce(ent)
    local player_name = entity.get_player_name(ent)

    -- Ensure resolver data exists
    if not resolver_data[player_name] then
        resolver_data[player_name] = { last_real_angle = 0, missed_shots = 0 }
    end

    if resolver_data[player_name].missed_shots > 3 then
        local last_real = resolver_data[player_name].last_real_angle or 0

        -- Smart anti-bruteforce flipping
        local random_offset = client.random_int(-10, 10) or 0  
        local new_angle = 180 - last_real + random_offset

        -- Prevent too obvious flipping
        if math.abs(new_angle - last_real) < 15 then
            new_angle = last_real + client.random_int(-15, 15)
        end

        resolver_data[player_name].last_real_angle = new_angle
        entity.set_prop(ent, "m_angEyeAngles", new_angle)

        throttled_log("ðŸ›¡ï¸ Anti-Bruteforce Activated: Adjusted Angle for " .. player_name)
    end
end

local function auto_yaw_bruteforce(ent)
    local player_name = entity.get_player_name(ent)

    if resolver_data[player_name].missed_shots >= 3 then
        local offsets = {-45, 45, -90, 90, 180}
        local last_real = resolver_data[player_name].last_real_angle or 0
        local new_yaw = last_real + offsets[client.random_int(1, #offsets)]

        entity.set_prop(ent, "m_angEyeAngles", new_yaw)
        resolver_data[player_name].missed_shots = 0  -- Reset misses

        throttled_log("ðŸ”„ Yaw Bruteforce Applied: Adjusted for " .. player_name)
    end
end


-- Function to adjust based on missed shots
local function dynamic_adjustment(ent)
    local player_name = entity.get_player_name(ent)

    -- Ensure resolver data exists
    if not resolver_data[player_name] then
        resolver_data[player_name] = { missed_shots = 0, angle_history = {} }
    end

    if resolver_data[player_name].missed_shots > 2 then
        local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
        local fake_angle = entity.get_prop(ent, "m_flPoseParameter") or 0

        -- **Use previous angles to adjust**
        local last_angle = resolver_data[player_name].angle_history[#resolver_data[player_name].angle_history] or 0
        local adjusted_angle = (real_angle + last_angle) / 2

        -- Apply dynamic inversion if needed
        if resolver_data[player_name].missed_shots % 2 == 0 then
            adjusted_angle = fake_angle
        end

        -- Store for future adjustments
        table.insert(resolver_data[player_name].angle_history, adjusted_angle)

        -- Prevent memory issues (limit history to 10)
        if #resolver_data[player_name].angle_history > 10 then
            table.remove(resolver_data[player_name].angle_history, 1)
        end

        -- Apply adjusted angles
        entity.set_prop(ent, "m_angEyeAngles", adjusted_angle)

        throttled_log("ðŸ”„ Dynamic Adjustment: Applied New Angle for " .. player_name)
    end
end


-- Function to track opponent movement patterns
local function track_opponent_patterns(ent)
    local player_name = entity.get_player_name(ent)

    local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
    local fake_angle = entity.get_prop(ent, "m_flPoseParameter") or 0

    -- Prevent invalid values (NaN, infinite values)
    if real_angle ~= real_angle or fake_angle ~= fake_angle or math.abs(real_angle) > 180 or math.abs(fake_angle) > 180 then
        return
    end

    -- Get reference to the player's stored patterns
    local aa_patterns = resolver_data[player_name].aa_patterns

    -- Check for AA flipping/jitter with nil check
    local last_real = resolver_data[player_name].last_real_angle or 0
    if math.abs(real_angle - last_real) > 30 then
        resolver_data[player_name].angle_switch_count = (resolver_data[player_name].angle_switch_count or 0) + 1
    end
    -- Store pattern
    table.insert(aa_patterns, { real = real_angle, fake = fake_angle, tick = globals.tickcount() })

    -- **Limit history to 10 entries** (prevents memory bloat)
    if #aa_patterns > 10 then
        table.remove(aa_patterns, 1)
    end

    -- Store last angles for tracking
    resolver_data[player_name].last_real_angle = real_angle
    resolver_data[player_name].last_fake_angle = fake_angle

     -- Add nil check before comparison
     if (resolver_data[player_name].angle_switch_count or 0) >= 3 then
        throttled_log("âš ï¸ " .. player_name .. " is using Jitter AA!")
        resolver_data[player_name].angle_switch_count = 0 -- Reset counter after detection
    end
end


-- Function to optimize latency-based prediction
local function latency_optimized_prediction(ent)
    local player_name = entity.get_player_name(ent)
    local latency = client.latency()
    local tick_interval = globals.tickinterval()
    local tick_offset = latency / tick_interval

    if type(resolver_data[player_name]) ~= "table" then
        resolver_data[player_name] = { angle_history = {} }
    end

    local real_angle = entity.get_prop(ent, "m_angEyeAngles")
    if type(real_angle) == "table" then
        real_angle = real_angle[2] or 0 -- Extract Yaw
    else
        real_angle = real_angle or 0
    end

    if type(resolver_data[player_name].angle_history) ~= "table" then
        resolver_data[player_name].angle_history = {}
    end

    table.insert(resolver_data[player_name].angle_history, real_angle)

    if #resolver_data[player_name].angle_history > 10 then
        table.remove(resolver_data[player_name].angle_history, 1)
    end

    local avg_change = 0
    for i = 2, #resolver_data[player_name].angle_history do
        local prev_angle = resolver_data[player_name].angle_history[i - 1] or 0
        local curr_angle = resolver_data[player_name].angle_history[i] or 0

        if type(prev_angle) ~= "number" then prev_angle = 0 end -- Fix
        if type(curr_angle) ~= "number" then curr_angle = 0 end -- Fix

        avg_change = avg_change + math.abs(curr_angle - prev_angle)
    end
    avg_change = avg_change / math.max(1, (#resolver_data[player_name].angle_history - 1))

    local future_angle = real_angle + avg_change * tick_offset

    resolver_data[player_name].last_real_angle = future_angle
    entity.set_prop(ent, "m_angEyeAngles", future_angle)
end

-- Function to resolve freestanding
local function resolve_freestanding(ent)
    local player_name = entity.get_player_name(ent)
    local velocity_x, velocity_y = entity.get_prop(ent, "m_vecVelocity") or 0, 0
    local speed = math.sqrt(velocity_x^2 + velocity_y^2) -- Get movement speed
    local duck_amount = entity.get_prop(ent, "m_flDuckAmount") or 0
    local left_trace, left_hit = client.trace_line(ent, -50, 0, 0, 50, 0, 0)
    local right_trace, right_hit = client.trace_line(ent, 50, 0, 0, -50, 0, 0)

    -- Adaptive freestanding logic
    if left_hit < right_hit then
        entity.set_prop(ent, "m_angEyeAngles", -90)  -- Face right
    else
        entity.set_prop(ent, "m_angEyeAngles", 90)   -- Face left
    end

    -- Adjust for movement states
    if speed > 5 then
        resolve_desync(ent)  -- Peeking
    elseif duck_amount > 0 then
        resolve_aa_exploit(ent)  -- Crouching
    else
        resolve_aa_exploit(ent)  -- Standing
    end
end

local function adaptive_flip_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local last_flip = resolver_data[player_name].last_flip_time or 0
    local current_time = globals.realtime()

    --  time-based flipping
    if current_time - last_flip > client.random_float(1.5, 3.5) then
        local last_real = resolver_data[player_name].last_real_angle or 0
        local new_angle = 180 - last_real + client.random_int(-10, 10)

        -- Ensure unpredictability
        if math.abs(new_angle - last_real) < 20 then
            new_angle = last_real + client.random_int(-20, 20)
        end

        resolver_data[player_name].last_real_angle = new_angle
        entity.set_prop(ent, "m_angEyeAngles", new_angle)
        resolver_data[player_name].last_flip_time = current_time

        throttled_log("ðŸ›¡ï¸ Anti-Bruteforce Activated: Flipped Angle for " .. player_name)
    end
end


local function detect_exploit_shots(ent)
    local player_name = entity.get_player_name(ent)

    local tick_base = entity.get_prop(ent, "m_nTickBase") or 0
    local choked_ticks = globals.chokedcommands()
    local current_time = globals.realtime()

    if not resolver_data[player_name] then
        resolver_data[player_name] = { missed_shots = 0, exploit_detected = false }
    end

    -- **Detect Double Tap (DT)**
    if choked_ticks >= 3 and choked_ticks <= 14 then
        throttled_log("ðŸ’¥ [DT] Double Tap DETECTED on " .. player_name)
        resolver_data[player_name].exploit_detected = true
    end

    -- **Detect Hideshots**
    if choked_ticks > 5 then
        throttled_log("ðŸš¨ [HIDESHOT] Hideshot Exploit DETECTED on " .. player_name)
        resolver_data[player_name].exploit_detected = true
    end

    -- **Detect Defensive AA (Quick Flicks to Avoid Damage)**
    if resolver_data[player_name].missed_shots > 2 and choked_ticks < 2 then
        throttled_log("ðŸ›¡ï¸ [DEF AA] Defensive AA DETECTED on " .. player_name)
        resolver_data[player_name].exploit_detected = true
    end

    -- **Instant Countermeasures**
    if resolver_data[player_name].exploit_detected then
        resolver_data[player_name].missed_shots = 0  -- Reset misses
        resolver_data[player_name].exploit_detected = false  -- Reset flag

        -- **Force a resolver adjustment instantly**
        adaptive_flip_resolver(ent)
        entity.set_prop(ent, "m_nHitboxSet", "Pelvis")

        throttled_log("âš ï¸ Countermeasure Activated: Adjusted Hitbox for " .. player_name)
    end
end

local function adjust_hitbox_based_on_aa(ent)
    local player_name = entity.get_player_name(ent)
    local jitter_detected = resolver_data[player_name].angle_switch_count and resolver_data[player_name].angle_switch_count >= 3
    local is_fake_ducking = (entity.get_prop(ent, "m_flDuckAmount") or 0) > 0.4

    if jitter_detected then
        entity.set_prop(ent, "m_nHitboxSet", "Stomach")
        throttled_log("âš ï¸ Jitter AA Detected - Adjusting to Stomach hitbox")
    elseif is_fake_ducking then
        entity.set_prop(ent, "m_nHitboxSet", "Pelvis")
        throttled_log("ðŸ¦† Fake Duck Detected - Aiming Pelvis")
    else
        entity.set_prop(ent, "m_nHitboxSet", "Head")
    end
end


local function defensive_aa_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local current_real = entity.get_prop(ent, "m_angEyeAngles") or 0
    local current_time = globals.realtime()

    -- Ensure resolver data exists
    if not resolver_data[player_name] then
        resolver_data[player_name] = { last_real_angle = current_real, angle_switch_count = 0 }
    end

    local last_real = resolver_data[player_name].last_real_angle
    if math.abs(current_real - last_real) > 20 then
        resolver_data[player_name].angle_switch_count = resolver_data[player_name].angle_switch_count + 1
    end

    -- If defensive AA flick detected, predict next movement
    if resolver_data[player_name].angle_switch_count >= 2 then
        local counter_angle = last_real + client.random_int(-5, 5)
        entity.set_prop(ent, "m_angEyeAngles", counter_angle)

        -- Adjust hitbox targeting to **stomach or pelvis**
        entity.set_prop(ent, "m_nHitboxSet", "Stomach")
        throttled_log("ðŸ›¡ï¸ Defensive AA Detected & Countered on " .. player_name)
    end

    resolver_data[player_name].last_real_angle = current_real
end


-- Function to resolve Fake Duck exploiters
local function fix_fake_duck(ent)
    local player_name = entity.get_player_name(ent)
    local flags = entity.get_prop(ent, "m_fFlags") or 0
    local duck_amount = entity.get_prop(ent, "m_flDuckAmount") or 0
    local velocity = math.abs(entity.get_prop(ent, "m_vecVelocity[0]") or 0) + math.abs(entity.get_prop(ent, "m_vecVelocity[1]") or 0)

    -- Detect if the enemy is fake-ducking (duck_amount is stuck around 0.6 while moving)
    local is_fake_ducking = duck_amount > 0.4 and duck_amount < 0.7 and velocity < 5

    -- Avoid wrong flips when fake ducking is detected
    if is_fake_ducking then
        resolver_data[player_name] = resolver_data[player_name] or {}
        resolver_data[player_name].last_fake_duck = globals.realtime()

        -- Prioritize lower hitboxes when aiming
        entity.set_prop(ent, "m_nHitboxSet", "Pelvis")
        throttled_log("ðŸ¦† Detected Fake Duck: Adjusting hitbox for " .. player_name)
    end
end


-- Function to resolve Edge Yaw
local function edge_yaw_counter(ent)
    local origin_x, origin_y, origin_z = entity.get_origin(ent)
    local left_trace = client.trace_line(ent, origin_x - 50, origin_y, origin_z, origin_x + 50, origin_y, origin_z)
    local right_trace = client.trace_line(ent, origin_x + 50, origin_y, origin_z, origin_x - 50, origin_y, origin_z)

    if left_trace < right_trace then
        entity.set_prop(ent, "m_angEyeAngles", -90)
    else
        entity.set_prop(ent, "m_angEyeAngles", 90)
    end
end

local function anti_miss_correction(ent)
    local player_name = entity.get_player_name(ent)

    if resolver_data[player_name].missed_shots >= 3 then
        resolver_data[player_name].missed_angles = resolver_data[player_name].missed_angles or {}
        table.insert(resolver_data[player_name].missed_angles, entity.get_prop(ent, "m_angEyeAngles"))

        if #resolver_data[player_name].missed_angles > 5 then
            table.remove(resolver_data[player_name].missed_angles, 1)
        end

        local new_angle = entity.get_prop(ent, "m_angEyeAngles") + 30
        entity.set_prop(ent, "m_angEyeAngles", new_angle)

        throttled_log("ðŸ”„ Anti-Miss Correction: Adjusted yaw for " .. player_name)
    end
end

local function lag_compensation_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local latency = client.latency()

    if latency > 0.1 then
        resolver_data[player_name].backtrack_positions = {}
        throttled_log("âš ï¸ Ping Spike Detected - Adjusting backtrack")
    end
end


-- deep jitter resolver
local function deep_jitter_resolver(ent)
    local player_name = entity.get_player_name(ent)

    if type(resolver_data[player_name]) ~= "table" then
        resolver_data[player_name] = { angle_history = {} }
    end

    if type(resolver_data[player_name].angle_history) ~= "table" then
        resolver_data[player_name].angle_history = {}
    end

    local current_angle = entity.get_prop(ent, "m_angEyeAngles")
    if type(current_angle) == "table" then
        current_angle = current_angle[2] or 0
    else
        current_angle = current_angle or 0
    end

    -- Prevent invalid values
    if not current_angle or current_angle ~= current_angle or math.abs(current_angle) > 180 then
        return
    end

    local tick_count = globals.tickcount()
    table.insert(resolver_data[player_name].angle_history, {angle = current_angle, tick = tick_count})

    if #resolver_data[player_name].angle_history > 15 then
        table.remove(resolver_data[player_name].angle_history, 1)
    end

    local avg_change, total_weight = 0, 0
    for i = 2, #resolver_data[player_name].angle_history do
        local prev_angle_data = resolver_data[player_name].angle_history[i - 1]
        if type(prev_angle_data) ~= "table" then prev_angle_data = { angle = 0 } end

        local prev_angle = prev_angle_data.angle or 0
        local diff = math.abs(current_angle - prev_angle)

        local weight = i / #resolver_data[player_name].angle_history
        avg_change = avg_change + (diff * weight)
        total_weight = total_weight + weight
    end

    avg_change = avg_change / math.max(1, total_weight)

    if avg_change > 18 then
        local last_angle_data = resolver_data[player_name].angle_history[#resolver_data[player_name].angle_history - 1]
        if type(last_angle_data) ~= "table" then last_angle_data = { angle = 0 } end

        local last_angle = last_angle_data.angle or 0
        local future_angle = last_angle + avg_change * client.random_int(-1, 1)

        -- Prevent infinite or NaN values
        if not future_angle or future_angle ~= future_angle or math.abs(future_angle) > 180 then
            return
        end

        entity.set_prop(ent, "m_angEyeAngles", future_angle)

        local current_time = globals.realtime()
        if not last_log_time[player_name] or (current_time - last_log_time[player_name]) > 2 then
            throttled_log("ðŸš¨ Jitter Detected & Countered on " .. player_name .. " | Predicting Angle: " .. string.format("%.2f", future_angle))
            last_log_time[player_name] = current_time
        end
    end
end


-- Randomized Yaw Resolver
local function improved_yaw_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local current_yaw = entity.get_prop(ent, "m_angEyeAngles") or 0
    local latency_ticks = math.floor(client.latency() / globals.tickinterval()) -- Adjust for latency

    -- Ensure resolver data exists
    if not resolver_data[player_name] then
        resolver_data[player_name] = { yaw_history = {}, flip_count = 0, last_flip_time = 0 }
    end

    -- **Ensure flip_count exists**
    if resolver_data[player_name].flip_count == nil then
        resolver_data[player_name].flip_count = 0
    end

    local yaw_history = resolver_data[player_name].yaw_history

    -- Store last **8** yaw values for better prediction
    table.insert(yaw_history, current_yaw)
    if #yaw_history > 8 then
        table.remove(yaw_history, 1)
    end

    -- Detect jitter patterns and predict next flip
    local flips = 0
    for i = 2, #yaw_history do
        if math.abs(yaw_history[i] - yaw_history[i - 1]) > 35 then
            flips = flips + 1
        end
    end

    -- If **3+ flips** detected, predict next yaw adjustment
    if flips >= 3 then
        local predicted_yaw = yaw_history[#yaw_history] + client.random_int(-10, 10)
        entity.set_prop(ent, "m_angEyeAngles", predicted_yaw)

        -- **Ensure `flip_count` is valid before modifying**
        resolver_data[player_name].flip_count = (resolver_data[player_name].flip_count or 0) + 1
        resolver_data[player_name].last_flip_time = globals.realtime()

        throttled_log("âš ï¸ Predicted Yaw Flip on " .. player_name .. " | Adjusting to: " .. predicted_yaw)
    end
end




-- Anti-Bruteforce Resolver
local function anti_bruteforce_resolver(ent)
    local player_name = entity.get_player_name(ent)
    if resolver_data[player_name].missed_shots > 3 then
        local last_real = resolver_data[player_name].last_real_angle or 0
        local flip_yaw = 180 - last_real + client.random_int(-5, 5)

        resolver_data[player_name].last_real_angle = flip_yaw
        entity.set_prop(ent, "m_angEyeAngles", flip_yaw)
    end
end

-- Fake Lag Resolver
local function fake_lag_resolver(ent)
    local player_name = entity.get_player_name(ent)
    local tickcount = globals.tickcount()
    local last_tick = resolver_data[player_name] and resolver_data[player_name].last_tick or 0
    local choked_ticks = globals.chokedcommands()

    -- Detect **low choke fake lag** (5-7 ticks)
    if choked_ticks > 2 and choked_ticks < 8 then
        throttled_log("ðŸš¨ Fake Lag Detected on " .. player_name)

        -- Reset missed shot count to avoid brute-force resolver exploit
        resolver_data[player_name].missed_shots = 0

        -- Correct movement desync
        local real_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
        entity.set_prop(ent, "m_angEyeAngles", real_angle + client.random_int(-5, 5)) 
    end

    resolver_data[player_name].last_tick = tickcount
end


-- Freestanding Resolver
local function freestanding_resolver(ent)
    local origin_x, origin_y, origin_z = entity.get_origin(ent)

    -- Trace left and right
    local left_trace, left_damage = client.trace_bullet(ent, origin_x - 50, origin_y, origin_z, origin_x + 50, origin_y, origin_z)
    local right_trace, right_damage = client.trace_bullet(ent, origin_x + 50, origin_y, origin_z, origin_x - 50, origin_y, origin_z)

    -- **Compare left vs. right damage and choose best angle**
    if left_damage > right_damage then
        entity.set_prop(ent, "m_angEyeAngles", 90) -- Face Right
    else
        entity.set_prop(ent, "m_angEyeAngles", -90) -- Face Left
    end
end

local function anti_miss_freestanding(ent)
    local player_name = entity.get_player_name(ent)
    local missed_shots = resolver_data[player_name].missed_shots or 0

    -- If we've missed 3 shots, **flip the resolver**
    if missed_shots >= 3 then
        local current_angle = entity.get_prop(ent, "m_angEyeAngles") or 0
        local flipped_angle = (current_angle > 0) and -90 or 90

        throttled_log("ðŸ”„ Flipping Freestanding Angle on " .. player_name)
        entity.set_prop(ent, "m_angEyeAngles", flipped_angle)

        -- Reset missed shots count after flipping
        resolver_data[player_name].missed_shots = 0
    end
end

-- Backtrack Resolver
local function backtrack_resolver(ent)
        local player_name = entity.get_player_name(ent)
        local pos_x, pos_y, pos_z = entity.get_origin(ent)
        local tick = globals.tickcount()
        local latency_ticks = math.floor(client.latency() / globals.tickinterval()) -- Compensate latency
    
        -- Ensure resolver data exists
        if not resolver_data[player_name] then
            resolver_data[player_name] = { backtrack_positions = {} }
        end
    
        -- Store **only valid** backtrack positions
        table.insert(resolver_data[player_name].backtrack_positions, {x = pos_x, y = pos_y, z = pos_z, tick = tick})
    
        -- Limit to best **3 positions** to avoid excess memory usage
        if #resolver_data[player_name].backtrack_positions > 3 then
            table.remove(resolver_data[player_name].backtrack_positions, 1)
        end
    
        -- Find **most vulnerable tick** (lowest movement speed)
        local best_position = nil
        local best_speed = math.huge
    
        for _, pos in ipairs(resolver_data[player_name].backtrack_positions) do
            local vel_x, vel_y = entity.get_prop(ent, "m_vecVelocity") or 0, 0
            local speed = math.sqrt(vel_x^2 + vel_y^2) -- Calculate movement speed
    
            if tick - pos.tick <= latency_ticks and speed < best_speed then
                best_position = pos
                best_speed = speed
            end
        end
    
        -- **Apply best backtrack tick**
        if best_position then
            entity.set_prop(ent, "m_vecOrigin", best_position.x, best_position.y, best_position.z)
            throttled_log("ðŸ“Œ Applied Best Backtrack Position for " .. player_name .. " (Speed: " .. best_speed .. ")")
        end
    end
    


local function smart_baim(ent)
    if not entity.is_enemy(ent) or not entity.is_alive(ent) then return end

    local player_name = entity.get_player_name(ent)
    local health = entity.get_prop(ent, "m_iHealth") or 100
    local armor = entity.get_prop(ent, "m_ArmorValue") or 0
    local has_helmet = entity.get_prop(ent, "m_bHasHelmet") == 1
    local velocity_x, velocity_y, velocity_z = entity.get_prop(ent, "m_vecVelocity")
    local speed = math.sqrt(velocity_x^2 + velocity_y^2 + velocity_z^2)
    local choked_ticks = globals.chokedcommands()
    local missed_shots = resolver_data[player_name] and resolver_data[player_name].missed_shots or 0

    -- Smart Baim Logic
    local should_baim = false
    if health <= 35 or (armor > 50 and has_helmet) then
        should_baim = true
    elseif speed < 5 then
        should_baim = true
    elseif choked_ticks > 5 then
        should_baim = true
    elseif missed_shots >= 2 then -- Adjust if missing shots
        should_baim = true
    end

    -- Logging
    if should_baim then
        throttled_log("ðŸŽ¯ Smart Baim Activated on " .. player_name .. " - Prioritizing Body")
    end

    -- Adjust Hitbox Based on Conditions
    local hitbox = should_baim and "Stomach" or "Head"
    entity.set_prop(ent, "m_nHitboxSet", hitbox)
end





local function fix_jump_miss(ent)
    local player_name = entity.get_player_name(ent)
    
    -- Fix bitwise operation using bit.band
    local flags = entity.get_prop(ent, "m_fFlags") or 0
    local airborne = bit.band(flags, 1) == 0 -- Checks if the player is in air (not on ground)
    
    local last_landed_time = resolver_data[player_name] and resolver_data[player_name].last_landed or 0
    local landed_recently = globals.realtime() - last_landed_time < 0.2

    if airborne then
        resolver_data[player_name] = resolver_data[player_name] or {}
        resolver_data[player_name].last_landed = globals.realtime()
        entity.set_prop(ent, "m_nHitboxSet", "Pelvis") -- Adjust for jumping enemies
    elseif landed_recently then
        resolver_data[player_name] = resolver_data[player_name] or {}
        resolver_data[player_name].missed_shots = 0 -- Reset miss count after landing
    end
end



-- Reset resolver data at round end
local function reset_resolver_data()
    resolver_data = {}  -- Clears all stored resolver data
    throttled_log("ðŸ”„ Resolver data reset at round end!")
end

client.set_event_callback("round_end", reset_resolver_data)

-- Main resolver function
local function ultimate_resolver(ent)
    -- Initialize data
    initialize_resolver_data(ent)

  -- Conditional checks using the ui_elements table
  if ui.get(ui_elements.enable_jitter_resolver) then
    deep_jitter_resolver(ent)
end

if ui.get(ui_elements.enable_yaw_resolver) then
    improved_yaw_resolver(ent)
end

if ui.get(ui_elements.enable_bruteforce_resolver) then
    anti_bruteforce_resolver(ent)
end

if ui.get(ui_elements.enable_fake_lag_resolver) then
    fake_lag_resolver(ent)
end

if ui.get(ui_elements.enable_freestanding_resolver) then
    freestanding_resolver(ent)
    anti_miss_freestanding(ent)
end

if ui.get(ui_elements.enable_fix_fake_duck) then
    fix_fake_duck(ent)
end

if ui.get(ui_elements.enable_backtrack_resolver) then
    backtrack_resolver(ent)
end
if ui.get(ui_elements.enable_adaptive_flip) then
    adaptive_flip_resolver(ent)
end

if ui.get(ui_elements.enable_exploit_detection) then
    detect_exploit_shots(ent)
end

if ui.get(ui_elements.enable_defensive_aa_resolver) then
    defensive_aa_resolver(ent)
end

if ui.get(ui_elements.enable_anti_miss_correction) then
    anti_miss_correction(ent)
end

if ui.get(ui_elements.enable_lag_compensation_resolver) then
    lag_compensation_resolver(ent)
end

if ui.get(ui_elements.enable_deep_fake_angle_recognition) then
    deep_fake_angle_recognition(ent)
end

if ui.get(ui_elements.enable_edge_yaw_counter) then
    edge_yaw_counter(ent)
end

if ui.get(ui_elements.enable_anti_miss_correction) then
    anti_miss_correction(ent)
end

if ui.get(ui_elements.enable_hitbox_adjustment) then
    adjust_hitbox_based_on_aa(ent)
end

if ui.get(ui_elements.enable_yaw_bruteforce) then
    auto_yaw_bruteforce(ent)
end
    -- Standard resolving logic
    resolve_freestanding(ent)
    latency_optimized_prediction(ent)
    track_opponent_patterns(ent)
    dynamic_adjustment(ent)
    prevent_bruteforce(ent)
    smart_baim(ent)
    fix_jump_miss(ent)
    resolve_desync(ent)
end

-- Main Resolver Loop
local function resolver_main()
    if not ui.get(ui_elements.enable_resolver) then return end

    local enemies = entity.get_players(true)
    for _, ent in ipairs(enemies) do
        ultimate_resolver(ent)
    end
end

-- Set event callback for resolver
client.set_event_callback("paint", resolver_main)

-- Register resolver to GameSense API
throttled_log("ðŸš€ P100 Ultimate Exploit Resolver Loaded!")

return resolver